#!/usr/bin/env python

###############################################################
# < next few lines under version control, D O  N O T  E D I T >
# $Date$
# $Revision$
# $Author$
# $Id$
###############################################################

###############################################################
# L96_varDA.py - cycle variational DA on Lorenz & Emanuel 1998
###############################################################

###############################################################
__author__    = "Rahul Mahajan"
__email__     = "rahul.mahajan@nasa.gov"
__copyright__ = "Copyright 2012, NASA / GSFC / GMAO"
__license__   = "GPL"
__status__    = "Prototype"
###############################################################

###############################################################
import sys
import numpy         as     np
from   scipy         import integrate, io
from   matplotlib    import pyplot
from   netCDF4       import Dataset
from   module_Lorenz import L96, plot_L96
from   module_DA     import *
from   module_IO     import *
from   plot_stats    import *
###############################################################

###############################################################
global Ndof, F, dF, lab
global A, Q, H, R
global nassim, ntimes, dt, t0
global Vupdate, minimization
global diag_fname, diag_fattr
global plots_Show, plots_Save

Ndof = 40
F    = 8.0
dF   = 0.1
lab  = []
for j in range(0,Ndof): lab.append( 'x' + str(j+1) )

A = np.eye(Ndof)             # initial analysis error covariance
Q = np.eye(Ndof)*0.0         # model error covariance ( covariance model is white for now)
H = np.eye(Ndof)             # obs operator ( eye(Ndof) gives identity obs )
R = np.eye(Ndof)*(4.0**2)    # observation error covariance

nassim = 200                 # no. of assimilation cycles
dt     = 1.0e-4              # time-step
ntimes = 0.05                # do assimilation every ntimes non-dimensional time units
t0     = 0.0                 # initial time

Vupdate = 1                  # DA method (1= 3Dvar; 2= 4Dvar)
maxiter = 1000               # maximum iterations
alpha   = 4e-3               # size of step in direction of normalized J
cg      = True               # True = Use conjugate gradient; False = Perform line search
minimization = [maxiter, alpha, cg]

diag_fname = 'L96_varDA_diag.nc4' # name of output diagnostic file
diag_fattr = {'F'           : str(F),
              'dF'          : str(dF),
              'ntimes'      : str(ntimes),
              'dt'          : str(dt),
              'Vupdate'     : str(Vupdate),
              'maxiter'     : str(maxiter),
              'alpha'       : str(alpha),
              'cg'          : str(int(cg))}


plots_Show = True              # plotting options to show figures
plots_Save = True              # plotting options to save figures
###############################################################

###############################################################
def main():

    # insure the same sequence of random numbers EVERY TIME
    np.random.seed(0)

    # check for valid variational data assimilation options
    check_varDA(Vupdate)

    # initial setup from LE1998
    x0    = np.ones(Ndof) * F
    x0[0] = 1.001 * F

    # Make a copy of truth for plotting later
    xt    = x0.copy()
    truth = x0.copy()

    # populate the initial state by perturbing the true state
    pert = 0.001 * np.random.randn(Ndof)
    xa = xt + pert
    xb = xa.copy()

    # load fixed background error covariance matrix; generated by L96_stats.py and compute inverse
    #data = io.loadmat('L96_climo_B.mat')
    #Bc   = data['B']copy
    nc = Dataset('L96_climo_B.nc4','r')
    Bc = nc.variables['B'][:]
    nc.close()

    print 'Cycling ON the attractor ...'

    ts = np.arange(t0,ntimes+dt,dt)     # time between assimilations

    # initialize arrays for statistics before cycling
    itstats = np.zeros(nassim) * np.NaN
    xbrmse  = np.zeros(nassim) * np.NaN
    xarmse  = np.zeros(nassim) * np.NaN
    xyrmse  = np.zeros(nassim) * np.NaN

    hist_ver = np.zeros((Ndof,nassim))
    hist_obs = np.zeros((Ndof,nassim))
    hist_xb  = np.zeros((Ndof,nassim))
    hist_xa  = np.zeros((Ndof,nassim))

    # create diagnostic file
    create_diag(diag_fname, diag_fattr, Ndof)
    write_diag(diag_fname, 0, xt, xb, xa, np.dot(H,xt), H, np.diag(R))

    for k in range(0, nassim):

        print '========== assimilation time = %d ========== ' % (k+1)

        # advance truth with the full nonlinear model
        xs = integrate.odeint(L96, xt, ts, (F,0.0))
        truth = np.vstack([truth, xs[1:,:]])
        xt    = xs[-1,:].copy()

        # new observations from noise about truth; set verification values
        y   = np.dot(H,xt) + np.random.randn(Ndof) * np.sqrt(np.diag(R))
        ver = xt.copy()

        # step to the next assimilation time
        xs = integrate.odeint(L96, xa, ts, (F+dF,0.0))
        xb = xs[-1,:].copy()

        # update step
        xa, A, itstats[k] = update_varDA(xb, Bc, y, R, H, Vupdate=Vupdate, minimization=minimization)

        # error statistics
        xbrmse[k] = np.sqrt( np.sum( (ver - xb)**2 ) / Ndof )
        xarmse[k] = np.sqrt( np.sum( (ver - xa)**2 ) / Ndof )
        xyrmse[k] = np.sqrt( np.sum( (ver -  y)**2 ) / Ndof )

        # history (for plotting)
        hist_ver[:,k] = ver
        hist_obs[:,k] = y
        hist_xb[:,k]  = xb
        hist_xa[:,k]  = xa

        # write diagnostics to disk
        write_diag(diag_fname, k+1, ver, xb, xa, y, H, np.diag(R))

        if ( plots_Show ):
            fig1 = plot_L96(obs=y, ver=ver, xa=xa, xb=xb, t=k+1, N=Ndof, figNum=1)
            pyplot.pause(0.1)

    print 'mean, max and min number of iterations : %d %d %d' %(np.int(np.mean(itstats)), np.max(itstats), np.min(itstats))

    # make some plots
    fig2 = plot_rmse(xbrmse, xarmse, yscale='linear')
    fig3 = plot_iteration_stats(itstats)

    if plots_Save:
        fig2.savefig('L96_varRMSE.png',dpi=100,orientation='landscape',format='png')
        fig3.savefig('L96_varItStats.png',dpi=100,orientation='landscape',format='png')

    if ( plots_Show ): pyplot.show()
###############################################################

###############################################################
if __name__ == "__main__":
	main()
###############################################################
