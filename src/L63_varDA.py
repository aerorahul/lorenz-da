#!/usr/bin/env python

###############################################################
# < next few lines under version control, D O  N O T  E D I T >
# $Date$
# $Revision$
# $Author$
# $Id$
###############################################################

###############################################################
# L63_varDA.py - cycle variational DA on the 1963 Lorenz attractor
###############################################################

###############################################################
__author__    = "Rahul Mahajan"
__email__     = "rahul.mahajan@nasa.gov"
__copyright__ = "Copyright 2011, NASA / GSFC / GMAO"
__license__   = "GPL"
__status__    = "Prototype"
###############################################################

###############################################################
import numpy    as     np
from   netCDF4  import Dataset
from   scipy    import integrate, io
from matplotlib import pyplot
from   lorenz   import L63, plot_L63
from   varDA    import ThreeDvar, FourDvar
from plot_stats import plot_trace, plot_abs_error
###############################################################

###############################################################
global Ndof, par, lab
global A, Q, H, R
global nassim, ntimes, dt
global Vupdate, maxiter, alpha, cg

# settings for Lorenz 63
Ndof = 3
par  = np.array([10.0, 28.0, 8.0/3.0])
lab  = ['x', 'y', 'z']

A = np.eye(Ndof)             # initial analysis error covariance
Q = np.eye(Ndof)*1.0         # model error covariance ( covariance model is white for now)
H = np.eye(Ndof)             # obs operator ( eye(Ndof) gives identity obs )
R = np.eye(Ndof)*2.0         # observation error covariance

nassim = 160                 # no. of assimilation cycles
dt     = 0.01                # time-step
ntimes = 0.25+dt             # do assimilation every ntimes non-dimensional time units

Vupdate = 1                  # DA method (1= 3Dvar; 2= 4Dvar)
maxiter = 1000               # maximum iterations
alpha   = 4e-3               # size of step in direction of normalized J
cg      = True               # True = Use conjugate gradient; False = Perform line search
###############################################################

###############################################################
def main():

    # insure the same sequence of random numbers EVERY TIME
    np.random.seed(0)

    # get a state on the attractor
    print 'running onto the attractor ...'
    x0 = np.array([10.0, 20.0, 30.0])   # initial conditions
    ts = np.arange(0.0,100.0+2*dt,2*dt) # how long to run on the attractor
    xs = integrate.odeint(L63, x0, ts, (par,0.0))

    # IC for truth taken from last time:
    xt = xs[-1,:].copy()

    # initial conditions from Miller et al., 1994
    xs = np.array([1.508870, -1.531271, 25.46091])
    xt = np.array([1.508870, -1.531271, 25.46091])

    # model error covariance matrix from Evensen 1997
    Q = np.array([[0.1491, 0.1505, 0.0007],
                  [0.1505, 0.9048, 0.0014],
                  [0.0007, 0.0014, 0.9180]])

    # Make a copy of truth for plotting later
    truth = xt.copy()
    truth = xs.copy()

    # populate the initial state by perturbing the true state
    pert = np.random.randn(3) * np.sqrt(2.0)
    xa = xt + pert

    # load fixed background error covariance matrix; generated by L63_stats.py and compute inverse
    #data = io.loadmat('L63_climo_B.mat')
    #Bc   = data['B']copy
    nc = Dataset('L63_climo_B.nc4','r')
    Bc = nc.variables['B'][:]
    nc.close()

    print 'Cycling ON the attractor ...'

    # initialize arrays for statistics before cycling
    itstats = np.zeros((nassim,1))
    xbe = np.zeros((Ndof,nassim))
    xae = np.zeros((Ndof,nassim))
    xye = np.zeros((Ndof,nassim))

    hist_ver = np.zeros((Ndof,nassim))
    hist_obs = np.zeros((Ndof,nassim))
    hist_xb  = np.zeros((Ndof,nassim))
    hist_xa  = np.zeros((Ndof,nassim))

    ts = np.arange(0,ntimes,dt)     # time between assimilations

    for k in range(0, nassim):

        print '========== assimilation time = %d ========== ' % (k+1)

        # advance truth with the full nonlinear model
        xs = integrate.odeint(L63, xt, ts, (par,0.0))
        truth = np.vstack([truth, xs[1:,:]])
        xt    = xs[-1,:].copy()

        # new observations from noise about truth; set verification values
        y   = np.dot(H,xt) + np.random.randn(Ndof) * np.sqrt(np.diag(R))
        ver = xt.copy()

        # step to the next assimilation time
        xs = integrate.odeint(L63, xa, ts, (par,0.0))
        xb = xs[-1,:].copy()

        # update step
        [xa, A, itstats[k]] = update_varDA(xb, Bc, y, R, H)

        # error statistics
        xbe[:,k] = xb - ver
        xae[:,k] = xa - ver
        xye[:,k] = y  - ver

        # history (for plotting)
        hist_ver[:,k] = ver
        hist_obs[:,k] = y
        hist_xb[:,k]  = xb
        hist_xa[:,k]  = xa

        # check for filter divergence
        if ( np.abs(xae[0,k]) > 10 and np.abs(xae[1,k]) > 10 ):
            print 'filter divergence at k = %d' % (k)
            #break

    print 'mean, max and min number of iterations : %5.3f %d %d' %(np.mean(itstats), np.max(itstats), np.min(itstats))

    # make some plots
    plot_L63(truth,segment=xs)
    plot_trace(obs=hist_obs, ver=hist_ver, xb=hist_xb, xa=hist_xa,label=lab,N=Ndof)
    plot_abs_error(xbe,xae,label=lab,N=Ndof)

    pyplot.show()
###############################################################

###############################################################
def update_varDA(xb, B, y, R, H):
    if ( Vupdate == 1 ):
        [xa, A, niters] = ThreeDvar(xb, B, y, R, H, maxiter=maxiter, alpha=alpha, cg=cg)

    elif ( Vupdate == 2 ):
        [xa, A, niters] = FourDvar(xb, B, y, R, H, maxiter=maxiter, alpha=alpha, cg=cg)

    else:
        print 'invalid update algorithm ...'
        sys.exit(2)

    return xa, A, niters
###############################################################

###############################################################
if __name__ == "__main__":
	main()
###############################################################
