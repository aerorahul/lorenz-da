#!/usr/bin/env python

###############################################################
# < next few lines under version control, D O  N O T  E D I T >
# $Date$
# $Revision$
# $Author$
# $Id$
###############################################################

###############################################################
# L63_3Dvar.py - cycle 3DVAR on the 1963 Lorenz attractor
#
# created : Oct 2011 : Rahul Mahajan : GMAO / GSFC / NASA
###############################################################

__author__    = "Rahul Mahajan"
__email__     = "rahul.mahajan@nasa.gov"
__copyright__ = "Copyright 2011, NASA / GSFC / GMAO"
__license__   = "GPL"
__status__    = "Prototype"

import numpy    as     np
from   netCDF4  import Dataset
from   scipy    import integrate, io
from   lorenz   import L63
from matplotlib import pyplot

# insure the same sequence of random numbers EVERY TIME
np.random.seed(0)

# number of degrees of freedom in the Lorenz 63 system
Ndof = 3

Q      = np.eye(Ndof)*0      # model error covariance
A      = np.eye(Ndof)        # initial analysis error covariance
R      = np.eye(Ndof)*1e-2   # observation error covariance
ntimes = 0.25                # do assimilation every ntimes non-dimensional time units
dt     = 0.01                # time-step
nassim = 160                 # no. of assimilation cycles
H      = np.eye(Ndof)        # obs operator ( eye(Ndof) gives identity obs )
alpha  = 4e-3                # size of step in direction of normalized J
cg     = True                # True = Use conjugate gradient; False = Perform line search

# control parameter settings for Lorenz 63
par = np.array([10.0, 28.0, 8.0/3.0])

# get a state on the attractor
print 'running onto the attractor ...'
x0 = np.array([10.0, 20.0, 30.0]) # initial conditions
ts = np.arange(0.0,100.0,2*dt)        # how long to run on the attractor
xs = integrate.odeint(L63, x0, ts, (par,0.0))

# IC for truth taken from last time:
Xt = xs[-1,:].copy()

# Make a copy of truth for plotting later
truth = Xt.copy()
truth = xs.copy()

# populate the initial state by perturbing the true state
pert = 1e-1 * np.random.randn(3)
Xa = Xt + pert

# load fixed background error covariance matrix; generated by L63_stats.py and compute inverse
#data = io.loadmat('L63_climo_B.mat')
#B    = data['B']copy
nc = Dataset('L63_climo_B.nc4','r')
B  = nc.variables['B'][:]
nc.close()
Binv = np.linalg.inv(B)

print 'Cycling ON the attractor ...'

# initialize arrays before cycling
itstats = np.zeros((nassim,1))
xbe = np.zeros((nassim,Ndof))
xae = np.zeros((nassim,Ndof))
xye = np.zeros((nassim,Ndof))

ts = np.arange(0,ntimes,dt)

for k in range(0, nassim):

    print '========== assimilation time = %d ========== ' % (k+1)

    # advance truth with the full nonlinear model
    xs = integrate.odeint(L63, Xt, ts, (par,0.0))
    truth = np.vstack([truth, xs[1:,:]])
    Xt = xs[-1,:].copy()
    Ver = Xt.copy()

    # new observations from noise about truth
    Y = np.dot(H,Xt) + np.diag(np.diag(np.random.randn(Ndof))*np.sqrt(R))

    # step to the next assimilation time
    xs = integrate.odeint(L63, Xa, ts, (par,0.0))
    Xb = xs[-1,:].copy()

    # 3DVAR update step

    # start with background
    X       = Xb.copy()
    niters  = 0
    maxiter = 100
    Jold    = 1e6
    J       = 0

    while ( np.abs(Jold -J) > 1e-5 ):

        if ( niters > maxiter ):
            print 'exceeded maximum iterations allowed'
            break

        Jold = J

        # cost function
        Jb = 2 * np.dot(np.transpose((X - Xb)), np.dot(Binv,(X-Xb)))
        Jo = 2 * np.dot(np.transpose((Y - np.dot(H,X))), np.dot(np.linalg.inv(R),(Y - np.dot(H,X))))
        J = Jb + Jo

        if ( niters == 0 ): print "initial cost = %10.5f" % J
        print "cost = %10.5f" % J

        # cost function gradient
        gJ = 2 * np.dot(Binv,(X - Xb)) - 2 * np.dot(np.linalg.inv(R),(Y-np.dot(H,X)))

        if ( cg ):
            if ( niters == 0 ):
                X = X - alpha * gJ
                cgJo = gJ
            else:
                beta = np.dot(np.transpose(gJ),gJ) / np.dot(np.transpose(gJo),gJo)
                cgJ = gJ + beta * cgJo
                X = X - alpha * cgJ
                cgJo = cgJ

            gJo = gJ
        else:
            X = X - alpha * gJ

        niters = niters + 1

    print 'final cost = %10.5f after %d iterations' % (J, niters)
    itstats[k] = niters

    # 3DVAR estimate
    Xa = X.copy()

    # analysis error covariance from Hessian
    A = np.linalg.inv( Binv + np.linalg.inv(R) )

    # error statistics
    xbe[k,:] = Xb - Ver
    xae[k,:] = Xa - Ver
    xye[k,:] = Y  - Ver

print 'mean, max and min number of iterations : %5.3f %d %d' %(np.mean(itstats), np.max(itstats), np.min(itstats))

xbev = np.var(xbe,axis=0,ddof=1)
xaev = np.var(xae,axis=0,ddof=1)
xbem = np.mean(xbe,axis=0)
xaem = np.mean(xae,axis=0)

lab = ['x', 'y', 'z']

fig = pyplot.figure(1)
pyplot.clf()
pyplot.semilogy(np.abs(xbe[:,0]),'b-',label='background',linewidth=2)
pyplot.semilogy(np.abs(xae[:,0]),'r-',label='analysis',linewidth=2)
strb = 'mean background : %5.4f +/- %5.4f' % (np.mean(np.abs(xbe[1:,0])), np.std(np.abs(xbe[1:,0]),ddof=1))
stra = 'mean analysis : %5.4f +/- %5.4f' % (np.mean(np.abs(xae[1:,0])), np.std(np.abs(xae[1:,0]),ddof=1))
str = strb + ' ' + stra
yl = pyplot.get(pyplot.gca(),'ylim')
yoff = yl[0] + yl[0]*0.12
pyplot.text(0,yoff,str,fontsize=10)
pyplot.xlabel('Assimilation Step',fontweight='bold',fontsize=12)
pyplot.ylabel('Absolute Error in x',fontweight='bold',fontsize=12)
pyplot.title('3DVAR Absolute Error (x)',fontweight='bold',fontsize=14)
pyplot.legend(loc=0)

fig = pyplot.figure(3)
pyplot.clf()
pyplot.hold(True)
for k in range(0,Ndof):
    pyplot.subplot(Ndof,1,k+1)
    pyplot.plot(np.abs(xbe[:,k]),'b-',label='background',linewidth=2)
    pyplot.plot(np.abs(xae[:,k]),'r-',label='analysis',linewidth=2)
    pyplot.ylabel(lab[k],fontweight='bold',fontsize=12)
    strb = 'mean background : %5.4f +/- %5.4f' % (np.mean(np.abs(xbe[1:,k])), np.std(np.abs(xbe[1:,k]),ddof=1))
    stra = 'mean analysis : %5.4f +/- %5.4f' % (np.mean(np.abs(xae[1:,k])), np.std(np.abs(xae[1:,k]),ddof=1))
    str = strb + ' ' + stra
    yl = pyplot.get(pyplot.gca(),'ylim')
    yoff = yl[0] - yl[1]*0.12
    pyplot.text(0,yoff,str,fontsize=10)
    if ( k == 0 ):
        pyplot.legend(loc=0)
        pyplot.title('3DVAR Absolute Error',fontweight='bold',fontsize=14)
    if ( k == Ndof-1 ):
        pyplot.xlabel('Assimilation Step',fontweight='bold',fontsize=12)

# Truth for the entire assimilation cycle
fig = pyplot.figure(2)
pyplot.clf()
pyplot.hold(True)
pyplot.plot(truth[:,0],truth[:,2],color='gray',linewidth=1)
pyplot.xlabel('X',fontweight='bold',fontsize=12)
pyplot.ylabel('Z',fontweight='bold',fontsize=12)
pyplot.title('Lorenz attractor',fontweight='bold',fontsize=14)
pyplot.plot(truth[50:100,0],truth[50:100,2],'ro',linewidth=2)

pyplot.show()
